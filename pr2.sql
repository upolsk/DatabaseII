--Give the following query (in ARAMIS database):
SELECT * FROM sz1;
--Is there a table named 'sz1' ? (Answer -> no)
select * from dba_tables where table_name = 'SZ1';
--Then which is the table (owner, table_name) whose records are displayed?
select * from dba_objects where object_name = 'SZ1';    --synonym
--You should find a table, a view is not enough.*/
select * from dba_synonyms where synonym_name = 'SZ1';  --table name is V1

--Create your own copy of EMP and DEPT tables (if you don't have already).
drop table dept;
drop table emp;
CREATE TABLE emp AS SELECT * FROM nikovits.emp;
CREATE TABLE dept AS SELECT * FROM nikovits.dept;

--Create a sequence to generate numbers for department number columns of the tables.
drop sequence dept_seq;
create sequence dept_seq start with 60 increment by 10;
INSERT INTO dept VALUES(dept_seq.nextval, 'TECHNOLOGY', 'KYRGYZSTAN');
INSERT INTO dept VALUES(dept_seq.nextval, 'IT', 'BISHKEK');

/*INSERT 2 new departments and 3 employees for each department. The department numbers
should be generated by the sequence.*/
select * from dept;
select * from emp;
drop procedure insert_dept_emp;
create or replace procedure insert_dept_emp is
begin
    for i in 1..3 loop
        insert into dept(deptno) values(deptno_seq.nextval);
        for j in 1..3 loop
            insert into emp(empno, deptno) values((deptno_seq.currval+j), deptno_seq.currval);
        end loop;
    end loop;
end;

set serveroutput on
execute insert_dept_emp();

call insert_dept_emp();

---------------------
CREATE DATABASE LINK aramisdb CONNECT TO ihlg15 IDENTIFIED BY ihlg15      
USING 'aramis.inf.elte.hu:1521/aramis';

drop database link aramisdb;

SELECT * FROM nikovits.emp@aramisdb;
select * from NIKOVITS.countries_v@aramisdb;
select * from NIKOVITS.rivers_v;

--Give the names of countries through which the Mekong river flows.
select rname, cname, countries from NIKOVITS.countries_v@aramisdb join NIKOVITS.rivers_v
on countries like '%' || tld || '%'
where rname = 'Mekong';

-- 1.Give the names and sizes of the database data files (*.dbf). (file_name, size_in_bytes)
select file_name, bytes from dba_data_files;

-- 2. Give the names of the tablespaces in the database. (tablespace_name)
select tablespace_name from dba_tablespaces;

-- 3. Which datafile belongs to which tablespace? List them. (filename, tablespace_name)
describe dba_data_files;
describe dba_tablespaces;

select file_name, tablespace_name from dba_data_files;

select df.file_name, ts.tablespace_name
from dba_tablespaces ts join dba_data_files df
on df.tablespace_name = ts.tablespace_name;


-- 4. Is there a tablespace that doesn't have any datafile in dba_data_files? -> see dba_temp_files
select tablespace_name from dba_tablespaces where tablespace_name not in (select tablespace_name from dba_data_files);

select tablespace_name from dba_tablespaces
minus
select tablespace_name from dba_data_files;

-- 5. What is the datablock size in USERS tablespace? (block_size)
select block_size from dba_tablespaces where tablespace_name = 'USERS';

-- 6. Find some segments whose owner is NIKOVITS. What segment types do they have? List the types. (segment_type)
select DISTINCT segment_type from dba_segments where owner = 'NIKOVITS';

--7. How many extents are there in file 'users02.dbf' ? (num_extents)
select count(*) as num_extents from dba_extents ex, dba_data_files df
where ex.file_id = df.file_id and df.file_name like '%users02.dbf';

--How many bytes do they occupy? (sum_bytes)
select sum(ex.bytes) as sum_bytes from dba_extents ex, dba_data_files df
where ex.file_id = df.file_id and df.file_name like '%users02.dbf';

select count(extent_id), sum(dba_extents.bytes)
from dba_data_files join dba_extents
on dba_data_files.file_id = dba_extents.file_id
where file_name like '%users02.dbf';

--8.How many free extents are there in file 'users02.dbf', and what is the summarized size of them ? (num, sum_bytes)
describe dba_free_space;
select count(*) as num from dba_data_files df, dba_free_space fs
where df.file_id = fs.file_id and df.file_name like '%users02.dbf';

--How many percentage of file 'users02.dbf' is full (allocated to some object)?
select round(sum(ex.bytes) / df.bytes, 2) * 100
from dba_data_files df join dba_extents ex
on df.file_id = ex.file_id
where file_name like '%users02.dbf'
group by df.bytes;
 
select count(block_id), sum(dba_free_space.bytes)
from dba_data_files join dba_free_space
on dba_data_files.file_id = dba_free_space.file_id
where file_name like '%users02.dbf';

select dba_data_files.bytes, count(block_id), dba_data_files.bytes-sum(dba_free_space.bytes)
from dba_data_files join dba_free_space
on dba_data_files.file_id = dba_free_space.file_id
where file_name like '%users02.dbf'
group by file_name,dba_data_files.bytes;


--9. Who is the owner whose objects occupy the most space in the database? (owner, sum_bytes)
select owner, sum(bytes) from dba_extents group by owner order by sum(bytes) desc fetch next 15 row only;

select * from(select owner, sum(bytes) from dba_segments group by owner order by sum(bytes) desc) where rownum = 1;

--10. Is there a table of owner NIKOVITS that has extents in at least two different datafiles? (table_name)
select segment_type, count(distinct(file_id)) from dba_extents where owner = 'NIKOVITS' and segment_type = 'TABLE' group by owner, segment_type having count(distinct(file_id)) > 1;


--11. On which tablespace is the table ORAUSER.dolgozo?
select tablespace_name from dba_segments where owner = 'ORAUSER' and segment_type = 'TABLE' and lower(segment_name) = 'dolgozo';

--On which tablespace is the table NIKOVITS.eladasok? Why NULL? 
 --(-> partitioned table, stored on more than 1 tablespace)
select tablespace_name from dba_segments where owner = 'NIKOVITS' and segment_type = 'TABLE' and lower(segment_name) = 'eladasok';


select owner, segment_name, blocks
from dba_segments
where bytes = 
(select max(bytes) from dba_segments where segment_type = 'INDEX')
and segment_type = 'INDEX';

select extent_id from dba_extents;


-----------------------------------------------
--Compulsory exercise
/*12. Write a PL/SQL procedure, which prints out for the parameter user his/her newest table (which was created last),
the size of the table in bytes (the size of the table's segment) and the creation date. 
The output format should be the following.
(Number of spaces doesn't count between the columns, date format is yyyy.mm.dd:hh24:mi)

Table_name: NNNNNN   Size: SSSSSS bytes   Created: yyyy.mm.dd.hh:mi*/

CREATE OR REPLACE PROCEDURE newest_table(p_user VARCHAR2) IS
tname varchar2(100);
tsize integer := 0;
tdate varchar2(100);
BEGIN
select object_name, timestamp into tname, tdate from dba_objects 
where object_type ='TABLE' and owner = p_user and
timestamp in (select max(timestamp) from dba_objects where object_type ='TABLE' and owner = p_user);

select bytes into tsize from dba_segments where owner = p_user and segment_name = tname;
DBMS_OUTPUT.PUT_LINE('Table_name: ' ||tname|| ' ' || 'Size: ' || tsize || ' bytes' || ' ' ||'Created: ' || tdate || ' ') ;
END;

SET SERVEROUTPUT ON
EXECUTE newest_table('NIKOVITS');

EXECUTE check_plsql('newest_table(''NIKOVITS'')');


